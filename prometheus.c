/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Prometheus QoS - you can "steal fire" from your ISP         */
/* "fair-per-IP" quality of service (QoS) utility              */
/* requires Linux 2.4.x or 2.6.x with HTB support              */
/* Copyright(C) 2005-2015 Michael Polak, Arachne Aerospace     */
/* iptables-restore support Copyright(C) 2007-2008 ludva       */
/* Credit: CZFree.Net,Martin Devera,Netdave,Aquarius,Gandalf  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/* Modified by: xChaos, 20171012
                 ludva, 20080415
 
   Prometheus QoS is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as 
   published by the Free Software Foundation; either version 2.1 of 
   the License, or (at your option) any later version.

   Prometheus QoS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Prometheus Qos; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA 
   
   GNU General Public License is located in file COPYING */

#include "cll1-0.6.2.h"
#include "ipstruct.h"

const char *version = "0.9.0-a";

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Versions: 0.9.0 is development release, 1.0 will be "stable"    */
/* Official Trac URL: https://dev.arachne.cz/svn/prometheus        */
/* Official SVN URL: https://dev.arachne.cz/repos/prometheus       */
/* BTC donations account: 19rriLx8vR19wGefPaMhakqnCYNYwjLvxq       */
/* CZK donations account: 2900242944/2010 (transparent account)    */
/* Warning: unofficial Github mirror is not supported by author!  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

const char *stats_html_signature = "<span class=\"small\">Statistics generated by Prometheus QoS version %s<br />GPL+Copyright(C)2005-2017 Michael Polak, <a target=\"_blank\" href=\"http://www.arachne.cz/\">Arachne Labs</a></span>\n";

#define STRLEN 512
#undef DEBUG

/* ======= All path names are defined here (for RPM patch) =======  */

const char               *tc = "/sbin/tc"; /* requires tc with HTB support */
const char         *iptables = "/sbin/iptables"; /* requires iptables utility */
const char        *ip6tables = "/sbin/ip6tables"; /* requires iptables utility */
const char     *iptablessave = "/sbin/iptables-save"; /* not yet required */
const char  *iptablesrestore = "/sbin/iptables-restore";  /* requires iptables-restore */
const char    *ip6tablessave = "/sbin/ip6tables-save"; /* not yet required */
const char *ip6tablesrestore = "/sbin/ip6tables-restore";  /* requires iptables-restore */
const char               *ls = "/bin/ls"; /* this is not user configurable :-) */

char          *config = "/etc/prometheus/prometheus.conf"; /* main configuration file */
char           *hosts = "/etc/prometheus/hosts"; /* per-IP bandwidth definition file */
char      *macrosfile = "/etc/prometheus/prometheus.macros"; /* rewrite rules for most common tariffs */
char    *upstreamfile = "/etc/prometheus/upstream.interfaces"; /* list of interfaces to manage */
char  *downstreamfile = "/etc/prometheus/downstream.interfaces"; /* list of interfaces to manage */
char    *iptablesfile = "/var/spool/prometheus.iptables"; /* temporary file for iptables-restore*/
char   *ip6tablesfile = "/var/spool/prometheus.ip6tables"; /* temporary file for ip6tables-restore*/
char          *credit = "/var/lib/misc/prometheus.credit"; /* credit log file */
char        *classmap = "/var/lib/misc/prometheus.classes"; /* credit log file */
char            *html = "/var/www/traffic.html"; /* hall of fame - html version */
char         *preview = "/var/www/preview.html"; /* hall of fame preview - html version */
char    *json_traffic = "/var/www/logs/traffic.json"; /* hall of fame - json version */
char    *json_preview = "/var/www/logs/preview.json"; /* hall of fame preview - json version */
char          *cmdlog = "/var/log/prometheuslog"; /* command log filename */
char         *log_dir = "/var/www/logs/"; /* log directory pathname, ended with slash */
char         *log_url = "/logs/"; /* log directory relative URI prefix (partial URL) */
char    *html_log_dir = "/var/www/logs/html/";

char      *jquery_url = "http://code.jquery.com/jquery-latest.js";
char         *lms_url = "/lms/?m=customerinfo&amp;id=";
int use_jquery_popups = TRUE;
int      row_odd_even = 0; /*<tr class="odd/even"> */
 
/* === Configuraration file values defaults - stored in global variables ==== */

int        filter_type = 1; /*1 mark, 2 classify*/
char      *final_chain = "DROP"; /* REJECT would be better, but it is impossible in mangle */
char             *mark = "MARK";
char    *mark_iptables = "MARK --set-mark ";
int            dry_run = FALSE; /* preview - use puts() instead of system() */
char *iptablespreamble = "*mangle\n:PREROUTING ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]";
char      *ip6preamble = "-A FORWARD -p ipv6-icmp -j ACCEPT\n-A POSTROUTING -p ipv6-icmp -j ACCEPT\n-A FORWARD -s fe80::/10 -j ACCEPT\n-A FORWARD -d ff00::/8 -j ACCEPT\n-A POSTROUTING -s fe80::/10 -j ACCEPT\n-A POSTROUTING -d ff00::/8 -j ACCEPT";
FILE    *iptables_file = NULL;
FILE   *ip6tables_file = NULL;
int      enable_credit = TRUE; /* enable credit file */
int         use_credit = FALSE; /* use credit file (if enabled)*/
char            *title = "Hall of Fame - Greatest Suckers"; /* hall of fame title */
int       hall_of_fame = TRUE; /* enable hall of fame */
char           *medium = "1000Mbit"; /* 10Mbit/100Mbit ethernet */
//obsolete: char              *lan = "eth0"; /* LAN interface */
//obsolete: char       *lan_medium = "1000Mbit"; /* 10Mbit/100Mbit ethernet */
char        *ip6prefix = NULL; /* Prefix for global /48 IPv6 subnet */
char         *qos_leaf = "sfq perturb 5"; /* leaf discipline */
char    *qos_free_zone = NULL; /* QoS free zone */
/* int          qos_proxy = TRUE; include proxy port to QoS */
int        found_lmsid = FALSE; /* show links to users in LMS information system */
int     include_upload = TRUE; /* upload+download=total traffic */
/* char         *proxy_ip = "192.168.1.1/32";  our IP with proxy port */
/* int         proxy_port = 3128; proxy port number */
//obsolete: long long int     line = 1024; /* WAN/ISP download in kbps */
//obsolete: long long int       up = 1024; /* WAN/ISP upload in kbps */
int           free_min = 256; /* minimum guaranted bandwidth for all undefined hosts */
int           free_max = 512; /* maximum allowed bandwidth for all undefined hosts */
int      overlimit_min = 256; /* minimum guaranted bandwidth for all undefined hosts */
int      overlimit_max = 512; /* maximum allowed bandwidth for all undefined hosts */
int     qos_free_delay = 0; /* seconds to sleep before applying new QoS rules */
int     digital_divide = 2; /* controls digital divide weirdness ratio, 1...3 */ 
int        max_nesting = 5; /* /include/uapi/linux/pkt_sched.h: #define TC_HTB_MAXDEPTH 8 [... - 3 parent classes] */
int            htb_r2q = 256; /* should work for leaf values 512 kbps to 8 Mbps */
int              burst = 8; /* HTB burst (in kbits) */
int         burst_main = 64;
int        burst_group = 32;
int     magic_treshold = 8; /* reduce ceil by X*magic_treshhold kbps (hard shaping) */
int       keywordcount = 0;
int        class_count = 0;
int           ip_count = 0;
FILE         *log_file = NULL;
char              *kwd = "via-prometheus"; /* /etc/hosts comment, eg. #qos-64-128 */

const int highest_priority   = 0; /* highest HTB priority (HTB built-in value is 0) */
const int lowest_priority    = 7; /* lowest HTB priority /include/uapi/linux/pkt_sched.h: #define TC_HTB_NUMPRIO 8 */
const int idxtable_treshold1 = 24;      /* this is no longer configurable */
const int idxtable_treshold2 = 12;      /* this is no longer configurable */
const int idxtable_bitmask1  = 3;        /* this is no longer configurable */
const int idxtable_bitmask2  = 3;        /* this is no longer configurable */

struct IP *ips = NULL, *networks = NULL, *ip, *sharedip;
struct Group *groups = NULL, *group;
struct Keyword *keyword, *defaultkeyword=NULL, *keywords = NULL;
struct Macro *macro, *macros = NULL;
struct Index *idxs = NULL, *idx, *metaindex;
struct Interface *interfaces = NULL, *interface;

#define FREE_CLASS      3
#define OVERLIMIT_CLASS 4

void help(void);
/* implemented in help.c */

void get_traffic_statistics(const char *whichiptables, int ipv6);
/* implemented in parseiptables.c */

void parse_ip_log(int argc, char **argv);
/* implemented in parselog.c */

void parse_hosts(char *hosts);
/* implemented in parsehosts.c */

void write_json_traffic(char *json);
/* implemented in json.c */

void write_htmlandlogs(char *html, char *d, int total, int just_preview);
/* implemented in htmlandlogs.c */

void analyse_topology(char *traceroute);
/* implemented in networks.c */

char *parse_datafile_line(char *str);
/* implemented in utils.c */

time_t get_mtime(const char *path);
/* implemented in utils.c */

const char *tr_odd_even(void)
{
 row_odd_even = 1 - row_odd_even;
 if(row_odd_even)
 {
  return "<tr class=\"even\">\n";
 }
 else
 {
  return "<tr class=\"odd\">\n";
 }
}


/* ====== iptables indexes are used to reduce complexity to log8(N) ===== */

char *index_id(char *ip, int bitmask);
/* function implemented in ipv4subnets.c */

char *subnet_id(char *ip, int bitmask);
/* function implemented in ipv4subnets.c */

char *index6_id(char *ip, int bitmask);
/* function implemented in ipv6subnets.c */

char *subnet6_id(char *ip, int bitmask);
/* function implemented in ipv6subnets.c */

/* ================= Let's parse configuration file here ================ */

void reject_config_and_exit(char *filename)
{
 printf("Configuration file %s rejected - abnormal exit.",filename);
 exit(-1);
}

void get_config(char *config_filename)
{
 char *cnf="mark";
 
 printf("Configured keywords: ");
 parse(config_filename)
 {
  option("keyword",kwd);
  if(kwd)
  {
   printf("%s ",kwd);

   create(keyword,Keyword);
   keyword->key = kwd;
   keyword->asymetry_ratio = 1;          /* ratio for ADSL-like upload */
   keyword->asymetry_fixed = 0;          /* fixed treshold for ADSL-like upload */
   keyword->data_limit = 8;              /* hard shaping: apply magic_treshold if max*data_limit MB exceeded */
   keyword->data_prio = 4;               /* soft shaping (qos): reduce HTB prio if max*data_prio MB exceeded */
   keyword->fixed_limit = 0;             /* fixed data limit for setting lower HTB ceil */
   keyword->fixed_prio = 0;              /* fixed data limit for setting lower HTB prio */
   keyword->reserve_min = 8;	         /* bonus for nominal HTB rate bandwidth (in kbps) */
   keyword->reserve_max = 0;	         /* malus for nominal HTB ceil (in kbps) */
   keyword->default_prio = highest_priority+1;
   keyword->download_aggregation = keyword->upload_aggregation = 0; /* disable by default */
   keyword->html_color = "000000";
   keyword->ip_count = 0;
   keyword->leaf_discipline = "";
   keyword->allowed_avgmtu = 0;

   push(keyword, keywords);
   if(!defaultkeyword)
   {
    defaultkeyword = keyword;
   }
   keywordcount++;
   
   kwd=NULL;
  }
  else
  {
    for_each(keyword,keywords)
    {
     int l=strlen(keyword->key);

     if(!strncmp(keyword->key,_,l) && strlen(_)>l+2)
     {
      char *tmptr=_; /*  <---- l+1 ----> */
      _+=l+1;        /*  via-prometheus-asymetry-ratio, etc. */
      foption("asymetry-ratio", keyword->asymetry_ratio);
      ioption("asymetry-treshold", keyword->asymetry_fixed);
      ioption("magic-relative-limit", keyword->data_limit);
      ioption("magic-relative-prio", keyword->data_prio);
      loption("magic-fixed-limit", keyword->fixed_limit);
      loption("magic-fixed-prio", keyword->fixed_prio);
      ioption("htb-default-prio", keyword->default_prio);
      ioption("htb-rate-bonus", keyword->reserve_min);
      ioption("htb-ceil-malus", keyword->reserve_max);
      ioption("download-aggregation", keyword->download_aggregation);
      ioption("upload-aggregation", keyword->upload_aggregation);
      option("leaf-discipline", keyword->leaf_discipline);
      option("html-color", keyword->html_color);
      ioption("allowed-avgmtu" ,keyword->allowed_avgmtu);
      _=tmptr;
      
      if(keyword->data_limit || keyword->fixed_limit || 
         keyword->data_prio || keyword->fixed_prio)
      {
       use_credit=1;        
      }
     }
    }
  }

  option("tc",tc);
  option("iptables",iptables);
  option("iptables-save",iptablessave);
  option("iptables-restore",iptablesrestore);
  option("ip6tables",ip6tables);
  option("ip6tables-save",ip6tablessave);
  option("ip6tables-restore",ip6tablesrestore);
  option("iptables-in-filename",iptablesfile);
  option("ip6tables-in-filename",ip6tablesfile);
  option("hosts",hosts);
  option("downstream-interfaces-list-filename",downstreamfile);
  option("upstream-interfaces-list-filename",upstreamfile);
  option("macros-filename",upstreamfile);
  option("ip6-prefix",ip6prefix);
  option("medium",medium);
  ioption("hall-of-fame-enable",hall_of_fame);
  ioption("digital-divide-weirdness-ratio",digital_divide);
  option("hall-of-fame-title",title);
  option("hall-of-fame-filename",html);
  option("json-filename",json_traffic);
  option("hall-of-fame-preview",preview);
  option("json-preview",json_preview);
  option("log-filename",cmdlog);
  option("credit-filename",credit);
  option("classmap-filename",classmap);
  ioption("credit-enable",enable_credit);
  option("log-traffic-directory",log_dir);
  option("log-traffic-html-directory",html_log_dir);
  option("log-traffic-url-path",log_url);
  option("jquery-url",jquery_url);
  option("lms-url",lms_url);
  ioption("use-jquery-popups",use_jquery_popups);
  option("qos-free-zone",qos_free_zone);
  ioption("qos-free-delay",qos_free_delay);
/*  ioption("qos-proxy-enable",qos_proxy); */
/*  option("qos-proxy-ip",proxy_ip);*/
  option("htb-leaf-discipline",qos_leaf);
/*  ioption("qos-proxy-port",proxy_port); */
  ioption("free-rate",free_min);
  ioption("free-ceil",free_max);
  ioption("overlimit-rate",overlimit_min);
  ioption("overlimit-ceil",overlimit_max);
  ioption("htb-burst",burst);
  ioption("htb-burst-main",burst_main);
  ioption("htb-burst-group",burst_group);
  ioption("htb-nesting-limit",max_nesting);
  ioption("htb-r2q",htb_r2q);
  ioption("magic-include-upload",include_upload);
  ioption("magic-treshold",magic_treshold);  
  option("filter-type", cnf);  
/* not yet implemented:
  ioption("magic-fixed-packets",fixed_packets);
  ioption("magic-relative-packets",packet_limit);
*/
 }
 fail
 { 
  perror(config_filename);
  puts("Warning - using built-in defaults instead ...");
 }
 done; /* ugly macro end */
 printf("\n");
 
 /* leaf discipline for keywords */
 for_each(keyword,keywords)
 {
  if(!strcmpi(keyword->leaf_discipline, ""))
  {
   keyword->leaf_discipline = qos_leaf;
  }
 }

 if(strcmpi(cnf, "mark"))
 {
  filter_type = 2;
  mark = "CLASSIFY";
  mark_iptables = "CLASSIFY --set-class 1:";
 }
 else
 {
  filter_type = 1;
  mark = "MARK";
  mark_iptables = "MARK --set-mark ";
 }
}

 
/* ========== This function executes, logs OR ALSO prints command ========== */

void safe_run(char *cmd)
{
 if(dry_run)
 {
  printf("\n=>%s\n",cmd);
 }
 else
 {
  system(cmd);
 }
 if(log_file)
 {
  fprintf(log_file,"%s\n",cmd);
 }
}

void iptables_save_line(char *line, int ipv6)
{
 if(ipv6)
 {
  fprintf(ip6tables_file,"%s\n",line);
 }
 else
 {
  fprintf(iptables_file,"%s\n",line);
 }
}

void run_iptables_restore(void)
{
 char *restor;
 string(restor, STRLEN);

 /*-----------------------------------------------------------------*/
 printf("Running %s <%s ...\n", iptablesrestore, iptablesfile);
 /*-----------------------------------------------------------------*/

 iptables_save_line("COMMIT", FALSE);
 fclose(iptables_file);
 if(dry_run) 
 {
  parse(iptablesfile)
  {
   printf("%s\n",_);
  }
  done; /* ugly macro end */
 }

 sprintf(restor,"%s <%s",iptablesrestore, iptablesfile);
 safe_run(restor);

 if(ip6prefix)
 {
  /*-----------------------------------------------------------------*/
  printf("Running %s <%s ...\n", ip6tablesrestore, ip6tablesfile);
  /*-----------------------------------------------------------------*/
  iptables_save_line("COMMIT", TRUE);
  fclose(ip6tables_file);
  if(dry_run) 
  {
   parse(ip6tablesfile)
   {
    printf("%s\n",_);
   }
   done; /* ugly macro end */
  }
  sprintf(restor,"%s <%s",ip6tablesrestore, ip6tablesfile);
  safe_run(restor);
 }
 free(restor);
}

/**/

char *parse_datafile_line(char *str);
time_t get_mtime(const char *path);

/*-----------------------------------------------------------------*/
/* Are you looking for int main(int argc, char **argv) ? :-))      */
/*-----------------------------------------------------------------*/

program
{
 int i=0;                    /* just plain old Fortran style integer :-) */
 FILE *f=NULL;               /* everything is just stream of bytes... */
 char *str, *ptr, *d;        /* LET A$=B$ :-) */
 char *substring, *limit_pkts;

 int parent        = 1;
 int just_networks = FALSE;  
 int just_flush    = FALSE;       /* deactivates all previous actions */
 int nodelay       = FALSE;
 int just_preview  = FALSE;       /* preview - generate just stats */
 int start_shaping = FALSE;       /* apply FUP - requires classmap file */
 int stop_shaping  = FALSE;       /* lift FUP - requires classmap file */
 int reduce_ceil     = 0;           /* allow only rate+(ceil-rate)/2, /4, etc. */
 int just_logs     = FALSE;       /* just parse logs */
 int run           = FALSE;
 int total         = 0;
 
 char *althosts=NULL;
  
 printf("\n\
Prometheus QoS - \"fair-per-IP\" Quality of Service setup utility.\n\
Version %s - Copyright (C)2005-2015 Michael Polak, Arachne Labs\n\
iptables-restore & burst tunning & classify modification by Ludva\n\
Credit: CZFree.Net, Martin Devera, Netdave, Aquarius, Gandalf\n\n",version);

 /*----- Boring... we have to check command line options first: ----*/   
 arguments
 {
  argument("-c") { nextargument(config); }
  argument("-h") { nextargument(althosts);}
  argument("-d") { run=TRUE; dry_run=TRUE; }
  argument("-f") { run=TRUE; just_flush=TRUE; }
  argument("-9") { run=TRUE; just_flush=9; }
  argument("-p") { run=TRUE; just_preview=TRUE; }
  argument("-q") { run=TRUE; just_preview=TRUE; stop_shaping=TRUE; }
  argument("-2") { run=TRUE; just_preview=TRUE; reduce_ceil=2; }
  argument("-4") { run=TRUE; just_preview=TRUE; reduce_ceil=4; }
  argument("-s") { run=TRUE; just_preview=TRUE; start_shaping=TRUE; }
  argument("-r") { run=TRUE; }
  argument("-n") { run=TRUE; nodelay=TRUE; }
  argument("-a") { run=TRUE; just_networks=TRUE; }
  argument("-l") { just_logs=TRUE; }
  argument("-m") { just_logs=TRUE; }
  argument("-y") { just_logs=TRUE; }
  argument("-?") { help(); exit(0); }
  argument("--help") { help(); exit(0); }
  argument("-v") { exit(0); } 
  argument("--version") { exit(0); } 
 }
 
 if(dry_run)
 {
  puts("*** THIS IS JUST DRY RUN ! ***\n");
 }

 date(d); /* this is typical cll1.h macro - prints current date */

 /*-----------------------------------------------------------------*/
 printf("Parsing configuration file %s ...\n", config);
 /*-----------------------------------------------------------------*/
 get_config(config);
 /*-----------------------------------------------------------------*/
 printf("Parsing upstream interfaces list %s ...\n", upstreamfile);
 /*-----------------------------------------------------------------*/
 parse(upstreamfile)
 {
  ptr = parse_datafile_line(_);
  if(ptr)
  {
   create(interface, Interface);
   interface->name = _;
   interface->speed = (long long)atol(ptr);
   /* is supplied value meaningful ?*/
   if(interface->speed <= 0)
   {
    printf("Illegal value of %s interface bandwidth.\n", interface->name);
    reject_config_and_exit(upstreamfile);
   }
   interface->is_upstream = TRUE;
   interface->chain = "FORWARD";
   interface->idxprefix = "forw";
   push(interface, interfaces);
   printf("Upstream interface %s: medium %s capacity %ld kbps\n", interface->name, medium, interface->speed);
  }
 }
 done; /* ugly macro end */

 /*-----------------------------------------------------------------*/
 printf("Parsing downstream interfaces list %s ...\n", downstreamfile);
 /*-----------------------------------------------------------------*/
 parse(upstreamfile)
 {
  ptr = parse_datafile_line(_);
  if(ptr)
  {
   create(interface, Interface);
   interface->name = _;
   interface->speed = (long long)atol(ptr);
   /* is supplied value meaningful ?*/
   if(interface->speed <= 0)
   {
    printf("Illegal value of %s interface bandwidth.\n", interface->name);
    reject_config_and_exit(downstreamfile);
   }
   interface->is_upstream = FALSE;
   interface->chain = "POSTROUTING";
   interface->idxprefix = "post";
   push(interface, interfaces);
   printf("Upstream interface %s: medium %s capacity %ld kbps\n", interface->name, medium, interface->speed);
  }
 }
 done; /* ugly macro end */

 
 if(just_logs)
 {
  parse_ip_log(argc,argv);
  exit(0);
 }
 else if(not run)
 {
  help();
  exit(0);
 }

 if(althosts)
 {
  hosts = althosts;
 }

 if(just_flush<9)
 {
  /*-----------------------------------------------------------------*/
  puts("Parsing iptables verbose output ...");
  /*-----------------------------------------------------------------*/
  get_traffic_statistics(iptables, FALSE);
  if(ip6prefix)
  {
   /*-----------------------------------------------------------------*/
   puts("Parsing ip6tables verbose output ...");
   /*-----------------------------------------------------------------*/  
   get_traffic_statistics(ip6tables, TRUE);
  }
 }

 /*-----------------------------------------------------------------*/
 /* cll1.h - let's allocate brand new character buffer...           */
 /*-----------------------------------------------------------------*/
 string(str, STRLEN); 
 string(limit_pkts, STRLEN);

 /*-----------------------------------------------------------------*/
 printf("Parsing macro definition file %s ...\n", macrosfile);
 /*-----------------------------------------------------------------*/
 parse(macrosfile)
 {
  ptr = parse_datafile_line(_);
  if(ptr)
  {
   create(macro, Macro);
   macro->rewrite_from = _;
   macro->rewrite_to = ptr;
   push(macro, macros);
   printf("%s -> %s\n", macro->rewrite_from, macro->rewrite_to);
  }
 }
 done; /* ugly macro end */



 /*-----------------------------------------------------------------*/
 printf("Parsing class defintion file %s ...\n", hosts);
 /*-----------------------------------------------------------------*/
 parse_hosts(hosts);
/*
 //this was pretty dumb idea anyway...
 if(just_networks)
 {
  analyse_topology("/usr/sbin/traceroute -n -m 10 -w 2 %s.%d");
  exit(-1); 
 }
*/

 /*-----------------------------------------------------------------*/
 puts("Resolving shared connections ...");
 /*-----------------------------------------------------------------*/
 for_each(ip, ips) if(ip->sharing)
 {
  for_each(sharedip, ips) if(eq(sharedip->name, ip->sharing))
  {
   sharedip->traffic += ip->traffic;
   sharedip->traffic_down += ip->direct;
   sharedip->traffic_up += ip->upload;
   ip->traffic = 0;
   ip->mark = sharedip->mark; 
   ip->lmsid = sharedip->lmsid;
   ip->pps_limit = sharedip->pps_limit; /* no other way to do this */

   /* Ugly hack: append IPv4 addresses of sharedip to IPv6 uplinks */
   ptr = strchr(ip->addr, '+');
   if(ptr && ptr-ip->addr > 1 && !sharedip->v6)
   {
    *(--ptr) = 0;
    concatenate(ip->addr, sharedip->addr, ptr);
    ip->name = ip->addr = ptr;
    ptr = strchr(ip->addr, '.');
    while(ptr && *ptr)
    {
     *ptr = ':';
     ptr = strchr(ptr, '.');
    }
    ip->mask += 64;
   }

   break;
  }
  if(not sharedip)
  {
   printf("Unresolved shared connection: %s %s sharing-%s\n",
          ip->addr, ip->name, ip->sharing);
  }
 }

 if(enable_credit && just_flush<9)
 {
  /*-----------------------------------------------------------------*/
  printf("Parsing credit file %s ...\n", credit);
  /*-----------------------------------------------------------------*/
  parse(credit)
  {
   ptr = parse_datafile_line(_);
   if(ptr)
   {
    if_exists(ip,ips,eq(ip->addr,_))
    {
     sscanf(ptr,"%Lu",&(ip->credit));
    }
   }
  }
  done; /* ugly macro end */
 }


 if(!just_preview)
 {
  /*-----------------------------------------------------------------*/
  puts("Initializing iptables and tc classes ...");
  /*-----------------------------------------------------------------*/
  
  iptables_file = fopen(iptablesfile, "w");
  if(iptables_file == NULL)
  {
    perror(iptablesfile);
    exit(-1);
  }
  iptables_save_line(iptablespreamble, FALSE);

  if(ip6prefix)
  {
   ip6tables_file = fopen(ip6tablesfile, "w");
   if(ip6tables_file == NULL)
   {
     perror(ip6tablesfile);
     exit(-1);
   }
   iptables_save_line(iptablespreamble, TRUE);
   iptables_save_line(ip6preamble, TRUE);
  }

  run_iptables_restore();
  
  log_file = fopen(cmdlog, "w");
  if(log_file == NULL) 
  {
    perror(cmdlog);
    exit(-1);
  }  
  
  for_each(interface, interfaces)
  {
   sprintf(str,"%s qdisc del dev %s root 2>/dev/null", tc, interface->name);
   safe_run(str);
  }
  
  iptables_file=fopen(iptablesfile,"w");
  iptables_save_line(iptablespreamble, FALSE);
  if(ip6prefix)
  {
   ip6tables_file=fopen(ip6tablesfile,"w");
   iptables_save_line(iptablespreamble, TRUE);
   iptables_save_line(ip6preamble, TRUE);
  }

  if(qos_free_zone && *qos_free_zone!='0') /* this is currently supported only for IPv4 */
  {
   for_each(interface, interfaces)
   {
    sprintf(str,"-A %s -s %s -o %s -j ACCEPT", interface->chain, qos_free_zone, interface->name);
    iptables_save_line(str, FALSE);
   }
  }
  
  if(ip_count > idxtable_treshold1 && !just_flush)
  {
   int idxcount=0, bitmask=32-idxtable_bitmask1;
   char *subnet, *buf;
   /*-----------------------------------------------------------------*/
   printf("Detected %d addresses - indexing iptables rules to improve performance...\n",ip_count);
   /*-----------------------------------------------------------------*/

   iptables_save_line(":post_common - [0:0]", FALSE);
   iptables_save_line(":forw_common - [0:0]", FALSE);
   if(ip6prefix)
   {
    iptables_save_line(":post_common - [0:0]", TRUE);
    iptables_save_line(":forw_common - [0:0]", TRUE);
   }

   for_each(ip,ips) if(ip->addr && *(ip->addr) && !eq(ip->addr,"0.0.0.0/0")) 
   {
    if(ip->v6)
    {
     buf=index6_id(ip->addr,bitmask+32);
    }
    else
    {
     buf=index_id(ip->addr, bitmask);
    }
    
    if_exists(idx,idxs,eq(idx->id,buf))
    {
     idx->children++;
    }
    else
    {
     create(idx,Index);
     idx->addr = ip->addr;
     idx->id = buf;
     idx->bitmask = bitmask+32*ip->v6;
     idx->parent = NULL;
     idx->children = 0;
     idx->ipv6 = ip->v6;
     idxcount++;
     push(idx,idxs);
    }
   }

   /* brutal perfomance optimalization */
   while(idxcount > idxtable_treshold2 && bitmask > 2*idxtable_bitmask2)
   {
    bitmask -= idxtable_bitmask2;
    idxcount = 0;

    for_each(idx,idxs) if(idx->parent == NULL)
    {
     if(idx->ipv6)
     {
      buf = index6_id(idx->addr, bitmask+32);
     }
     else
     {
      buf = index_id(idx->addr, bitmask);
     }
     if_exists(metaindex,idxs,eq(metaindex->id,buf))
     {
      metaindex->children++;
     }
     else
     {
      create(metaindex,Index);
      metaindex->addr = idx->addr;
      metaindex->id = buf;
      metaindex->bitmask = bitmask+32*idx->ipv6;
      metaindex->parent = NULL;
      metaindex->children = 0;
      metaindex->ipv6 = idx->ipv6;
      idxcount++;
      push(metaindex,idxs);
     }
     idx->parent=metaindex;
    }
   }

   /* this should slightly optimize throughput ... */
   sort(idx,idxs,desc_order_by,children);
   sort(idx,idxs,order_by,bitmask);

   i=0;
   for_each(idx, idxs)
   {
    if(idx->ipv6)
    {
     subnet=subnet6_id(idx->addr, idx->bitmask);
    }
    else
    {
     subnet=subnet_id(idx->addr, idx->bitmask);
    }
    printf("%d: %s/%d\n", ++i, subnet, idx->bitmask);
       
    sprintf(str,":post_%s - [0:0]", idx->id);
    iptables_save_line(str, idx->ipv6);

    sprintf(str,":forw_%s - [0:0]", idx->id);
    iptables_save_line(str, idx->ipv6);

    for_each(interface, interfaces)
    {
     if(idx->parent)
     {
      string(buf, strlen(idx->parent->id)+6);
      sprintf(buf, "%s_%s", interface->idxprefix, idx->parent->id);
     }
     else
     {
      buf = interface->chain;
     }

     sprintf(str,"-A %s -d %s/%d -o %s -j %s_%s", buf, subnet, idx->bitmask, interface->name, interface->idxprefix, idx->id);
     iptables_save_line(str, idx->ipv6);

     sprintf(str,"-A %s -d %s/%d -o %s -j %s_common", buf, subnet, idx->bitmask, interface->name, interface->idxprefix);
     iptables_save_line(str, idx->ipv6);
    }
   }
   printf("Total indexed iptables chains created: %d\n", i);

   for_each(interface, interfaces)
   {
    sprintf(str,"-A %s -o %s -j %s_common", interface->chain, interface->name, interface->idxprefix);
    iptables_save_line(str, FALSE);
    if(ip6prefix)
    {
     sprintf(str,"-A %s -o %s -j %s_common", interface->chain, interface->name, interface->idxprefix);
     iptables_save_line(str, TRUE);
    }
   }
  }
 }

 if(just_flush)
 {
  fclose(iptables_file);
  if(log_file)
  { 
   fclose(log_file);
  }
  puts("Just flushed iptables and tc classes - now exiting ...");
  exit(0);
 }

 if(!just_preview)
 {
  if(!dry_run && !nodelay && qos_free_delay)
  {
   printf("Flushed iptables and tc classes - now sleeping for %d seconds...\n", qos_free_delay);
   sleep(qos_free_delay);
  }

  for_each(interface, interfaces)
  {
   sprintf(str, "%s qdisc add dev %s root handle 1: htb r2q %d default 1",
                tc, interface->name, htb_r2q);
   safe_run(str);

   sprintf(str, "%s class add dev %s parent 1: classid 1:2 htb rate %s ceil %s burst %dk prio %d",
                tc, interface->name, medium, medium, burst_main, highest_priority);
   safe_run(str);

   sprintf(str, "%s class add dev %s parent 1:2 classid 1:1 htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d",
                tc, interface->name, interface->speed, interface->speed, burst_main, highest_priority);
   safe_run(str);
  }
 }

 /*-----------------------------------------------------------------*/
 puts("Locating heavy downloaders and generating root classes ...");
 /*-----------------------------------------------------------------*/
 sort(ip,ips,desc_order_by,traffic); 

 /*-----------------------------------------------------------------*/
 for_each(interface, interfaces)
 {
  long long int rate = interface->speed;
  long long int max = interface->speed;
  int group_count = 0;
 //obsolete: FILE *credit_file = NULL;
  
 //obsolete:  if(!just_preview && !dry_run && enable_credit)
 //obsolete:  {
 //obsolete:   credit_file = fopen(credit,"w");
 //obsolete:  }

  for_each(group,groups)
  {
   if(!just_preview)
   {
    sprintf(str, "%s class add dev %s parent 1:%d classid 1:%d htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d #down desired %d", 
                  tc, interface->name, parent, group->id, rate, max, burst_group, highest_priority+1, group->desired);
    safe_run(str);
   }

   if(group_count++ < max_nesting)
   {
    parent = group->id;
   }

   rate -= digital_divide*group->min;
   if(rate < group->min)
   {
    rate = group->min;
   }
    
   /*shaping of aggresive downloaders, with credit file support */
   /* obsolete
   if(use_credit)
   {
    int group_rate = group->min, priority_sequence = lowest_priority;
    
    for_each(ip, ips) if(ip->min == group->min && ip->max > ip->min)
    {
     ip->realquota=ip->credit+(ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20));
     if(     ip->keyword->data_limit 
         and not ip->fixedprio 
         and ip->traffic > ip->realquota )
     {
      if(group_rate < ip->max)
      {
       ip->max = group_rate;
      }
      group_rate+=magic_treshold;
      ip->prio=lowest_priority;
      if(ip->prio<highest_priority+2)
      {
       ip->prio=highest_priority+2;
      }
     }
     else
     {
      if(    ip->keyword->data_prio 
          && !ip->fixedprio 
          && (   ip->traffic >   ip->credit + (ip->min*ip->keyword->data_prio+(ip->keyword->fixed_prio<<20))) )
      {
       ip->prio=priority_sequence--;
       if(ip->prio<highest_priority+1)
       {
        ip->prio=highest_priority+1;
       }
      }
     
      if(credit_file)
      {
       unsigned long long lcredit=0;
       
       if((ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20))>ip->traffic)
       {
        lcredit=(ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20))-ip->traffic;
       }
       fprintf(credit_file,"%s %Lu\n",ip->addr,lcredit);
      }
     }
    }        
   } obsolete */
  }
  /* obsolete 
  if(credit_file)
  {
   fclose(credit_file);
  } obsolete */
 }

 if(just_preview)
 {
  if(start_shaping || stop_shaping || reduce_ceil)
  {
   time_t how_much_seconds = time(NULL) - get_mtime(classmap); /* sice start of daily aggregation session */
   printf("Reading %s (%ld seconds old) and applying Fair Use Policy and Aggregation rules... \n", classmap, how_much_seconds);
     
   parse(classmap)
   {
    ptr=strchr(_,' ');
    if(ptr)
    {
     *ptr=0;
     ptr++;
     if_exists(ip,ips,eq(ip->addr,_))
     {
      int unshape_this_ip = 0;
      long avg_mbps_down = ip->traffic_down * 8 / how_much_seconds; 
      long avg_mbps_up = ip->traffic_up * 8 / how_much_seconds;
      int agreg = 1, print_stats = 1;
      
      if(ip->keyword->download_aggregation)
      {
       int min_mbps = (ip->min/ip->keyword->download_aggregation)>>10;
       if(min_mbps < 1)
       {
        min_mbps = 1;
       }
  
       if(min_mbps <= avg_mbps_down)
       {
        unshape_this_ip = 0;
        agreg = (int)((float)(avg_mbps_down+1)/min_mbps+.5);
        ip->max /= agreg;
        ip->pps_limit /= agreg;
        printf("Download aggregation 1:%d for %s (min: %lu Mbps avg: %ld Mbps)\n", agreg, ip->name, min_mbps, avg_mbps_down);
       }
       else
       {
        unshape_this_ip = 1;
       }
      }
      else if(ip->keyword->upload_aggregation)
      {
       int min_mbps = (ip->min/ip->keyword->upload_aggregation)>>10;
       if(min_mbps < 1)
       {
        min_mbps = 1;
       }

       if(min_mbps <= avg_mbps_up)
       {
        unshape_this_ip = 0;
        agreg = (int)((float)(avg_mbps_up+1)/min_mbps+.5);
        ip->max /= agreg;
        printf("Upload aggregation 1:%d for %s: (min: %lu Mbps avg: %ld Mbps)\n", agreg, ip->name, min_mbps, avg_mbps_up);
       }
       else
       {
        unshape_this_ip = 1;
       }
      }
      if(stop_shaping)
      {
       unshape_this_ip = 1;
      }
      ip->aggregated = agreg;      
      ip->mark = atoi(ptr);
      if(ip->max < ip->desired || unshape_this_ip || reduce_ceil) /* apply or disable FUP limit immediately.... */
      {
       if(unshape_this_ip)
       {
        ip->max = ip->desired;
        if(stop_shaping) /* all limits removed, but not printed with -s (start_shaping) switch */
        {
         printf("Removing limit for %s (%s) ", ip->name, ip->addr);
        }
        else
        {
         print_stats = 0;
        }
       }
       else
       {
        printf("Updating %s (%s) ", ip->name, ip->addr);
        if(reduce_ceil)
        {
         ip->max = ip->min + (ip->desired-ip->min)/reduce_ceil;
        }
        else if(ip->max < ip->min)
        {
         ip->max = ip->min;
        }        
       }
       for_each(interface, interfaces)
       {
        if(!interface->is_upstream)
        {
         if(print_stats)
         {
          printf("[down %s: %dk-%dk wants %d]", interface->name, ip->min, ip->max, ip->desired);
         }
         sprintf(str, "%s class change dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d", 
                      tc, interface->name, ip->group, ip->mark, ip->min, ip->max, burst, ip->prio);
         safe_run(str);
        }
        else
        {
         if(print_stats)
         {
          printf("[up %s: %dk-%dk wants %dk]", interface->name, (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), 
                                             (int)((ip->desired/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed),
                                             (int)((ip->desired/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed));
         }
         sprintf(str,"%s class change dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d",
                      tc, interface->name, ip->group, ip->mark,
                      (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed),
                      (int)((ip->max/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), burst, ip->prio);
         safe_run(str);
        }
       }
       if(print_stats)
       {
        printf("\n");
       }
      }
     }
    }
   }
   fail
   { 
    perror(classmap);
    puts("Warning - classmap file not fund, just generating preview ...");
    start_shaping=FALSE;
    stop_shaping=FALSE;
   }
   done; /* ugly macro end */
  }
  html=preview;
  json_traffic=json_preview;
 }

 if(!dry_run && !just_flush)
 {
  /*-----------------------------------------------------------------*/
  printf("Writing json traffic overview  %s ... ", json_traffic);
  /*-----------------------------------------------------------------*/
  write_json_traffic(json_traffic);

  /*-----------------------------------------------------------------*/
  printf("Writing statistics into HTML page %s ...\n", html);
  /*-----------------------------------------------------------------*/
  write_htmlandlogs(html, d, total, just_preview);
 }

 if(just_preview)
 {
  char swchar='p';
  if(start_shaping)
  {
   swchar='s';
  }
  else if(reduce_ceil)
  {
   swchar='0'+reduce_ceil; /* -2, -4 */
  }
  else if(stop_shaping)
  {
   swchar='q';
  }

  printf("Statistics preview generated (-%c switch) - now exiting ...\n", swchar);
  exit(0);
 }  

 i=0;
#ifdef DEBUG
 printf("%-22s %-15s mark\n","name","ip");
#endif

 printf("Writing %s", classmap); 
 f = fopen(classmap, "w"); 
 if(f < 0)
 {
  perror(classmap);
 }

 /*-----------------------------------------------------------------*/
 printf(" + generating iptables and tc classes ... ");
 /*-----------------------------------------------------------------*/

 for_each(ip, ips) if(ip->mark > 0)
 {
  for_each(interface, interfaces)
  {
   char *chain;
   if(idxs)
   {
    char *buf;
    duplicate(ip->addr,buf);
    if(ip->v6)
    {
     buf=index6_id(ip->addr,64-idxtable_bitmask1);
    }
    else
    {
     buf=index_id(ip->addr,32-idxtable_bitmask1);
    }
    
    string(chain, 6+strlen(buf));
    sprintf(chain, "%s_", interface->idxprefix);
    strcat(chain, buf);

    free(buf);
   }
   else
   {
    chain = interface->chain;
   }

   /* packet limits - this will be optional in future */
   if(ip->pps_limit)
   {
    sprintf(limit_pkts, "-m limit --limit %d/s --limit-burst %d ", 
                        ip->pps_limit, ip->pps_limit);
   }
   else
   {
    *limit_pkts = 0;
   }  

 #ifdef DEBUG
   printf("%-22s %-16s %04d %d/s\n", ip->name, ip->addr, ip->mark, ip->pps_limit); 
 #endif

   /* ------------------------------------------------ iptables classify */
   sprintf(str, "-A %s -d %s/%d -o %s -j %s%d",
                chain, ip->addr, ip->mask,
                interface->name, mark_iptables, ip->mark);
   iptables_save_line(str, ip->v6);

   sprintf(str, "-A %s -d %s/%d -o %s %s-j ACCEPT",
                chain, ip->addr, ip->mask, interface->name, limit_pkts);
   iptables_save_line(str, ip->v6);

   /* classify overlimit packets to separate overlimit class */
   sprintf(str, "-A %s -d %s/%d -o %s -j %s%d",
                chain, ip->addr, ip->mask,
                interface->name, mark_iptables, OVERLIMIT_CLASS);
   iptables_save_line(str, ip->v6);

   sprintf(str, "-A %s -d %s/%d -o %s -j ACCEPT",
                chain, ip->addr, ip->mask, interface->name);
   iptables_save_line(str, ip->v6);

   if(ip->min)
   {
    //TODO - min and max should not exceed interface->speed
   
    /* -------------------------------------------------------- tc class */
 #ifdef DEBUG
    printf("[down: %dk-%dk]", ip->min, ip->max);
 #endif

    sprintf(str, "%s class add dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d", 
                 tc, interface->name, ip->group, ip->mark, ip->min, ip->max, burst, ip->prio);
    safe_run(str);

    if(strcmpi(ip->keyword->leaf_discipline, "none"))
    {
     sprintf(str, "%s qdisc add dev %s parent 1:%d handle %d %s", 
                  tc, interface->name, ip->mark, ip->mark, ip->keyword->leaf_discipline); /*qos_leaf*/
     safe_run(str);
    }

    if(filter_type == 1)
    {
     sprintf(str, "%s filter add dev %s parent 1:0 protocol ip handle %d fw flowid 1:%d",
                  tc, interface->name, ip->mark, ip->mark);
     safe_run(str);
    }
   }
   else
   {
 #ifdef DEBUG
    printf("(sharing %s)\n", ip->sharing);
 #endif
   }
   i++;
  }
  if(ip->min && f > 0)
  {
   fprintf(f, "%s %d\n", ip->addr, ip->mark);
  }
 }
 if(f > 0)
 {
  puts("done.");
  fclose(f);
 }

 for_each(interface, interfaces)
 {
  char *chain;
  if(idxs)
  {
   string(chain, STRLEN);
   sprintf(chain, "%s_common", interface->idxprefix);
  }
  else
  {
   chain = interface->chain;
  }

  if(free_min)
  {
   final_chain = "ACCEPT";

   sprintf(str, "-A %s -o %s -j %s%d",
                chain, interface->name, mark_iptables, FREE_CLASS);
   iptables_save_line(str, FALSE); /* only for IPv4 */
  }

  sprintf(str,"-A %s -o %s -j %s", chain, interface->name, final_chain);
  iptables_save_line(str, FALSE);
  if(ip6prefix)
  {
   sprintf(str,"-A %s -o %s -j %s", chain, interface->name, final_chain);
   iptables_save_line(str, TRUE);
  }

  if(free_min) /* allocate free bandwith if it is not zero... */ 
  {
   /*-----------------------------------------------------------------*/
   puts("Generating free bandwith class ...");
   /*-----------------------------------------------------------------*/
   sprintf(str, "%s class add dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d",
                tc, interface->name, parent, FREE_CLASS, free_min, free_max,burst, lowest_priority);
   safe_run(str);
   /* tc SFQ */
   if(strcmpi(qos_leaf, "none"))
   {
     sprintf(str,"%s qdisc add dev %s parent 1:%d handle %d %s", tc, interface->name, FREE_CLASS, FREE_CLASS, qos_leaf);
     safe_run(str);
   }   
   /* tc handle 1 fw flowid */
   sprintf(str,"%s filter add dev %s parent 1:0 protocol ip handle %d fw flowid 1:%d", tc, interface->name, FREE_CLASS, FREE_CLASS);
   safe_run(str);

   /*-----------------------------------------------------------------*/
   puts("Generating bandwith class for overlimit packets...");
   /*-----------------------------------------------------------------*/
   sprintf(str, "%s class add dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d",
                tc, interface->name, parent, OVERLIMIT_CLASS, overlimit_min, overlimit_max, burst, lowest_priority);
   safe_run(str);
  }
 } 
 printf("Total IP count: %d\n", i);
 run_iptables_restore();
 if(log_file)
 {
  fclose(log_file);
 }
 return 0;
 /* that's all folks, thank you for reading it all the way up to this point ;-) */
 /* bad luck C<<1 is not yet finished, I promise no sprintf() next time... */
}
