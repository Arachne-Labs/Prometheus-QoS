/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Prometheus QoS - you can "steal fire" from your ISP         */
/* "fair-per-IP" quality of service (QoS) utility              */
/* requires Linux 2.4.x or 2.6.x with HTB support              */
/* Copyright(C) 2005-2013 Michael Polak, Arachne Aerospace     */
/* iptables-restore support Copyright(C) 2007-2008 ludva       */
/* Credit: CZFree.Net,Martin Devera,Netdave,Aquarius,Gandalf  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

/* Modified by: xChaos, 20130124
                 ludva, 20080415
 
   Prometheus QoS is free software; you can redistribute it and/or
   modify it under the terms of the GNU General Public License as 
   published by the Free Software Foundation; either version 2.1 of 
   the License, or (at your option) any later version.

   Prometheus QoS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with Prometheus Qos; if not, write to the Free Software
   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301 USA 
   
   GNU General Public License is located in file COPYING */

#include "cll1-0.6.2.h"
#include "ipstruct.h"

const char *version = "0.8.3-i";

/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */
/* Versions: 0.8.3 is development release, 0.8.4 will be "stable"  */
/* Official Trac URL: https://dev.arachne.cz/svn/prometheus        */
/* Official SVN URL: https://dev.arachne.cz/repos/prometheus       */
/* BTC donations account: 19rriLx8vR19wGefPaMhakqnCYNYwjLvxq       */
/* CZK donations account: 2900242944/2010 (transparent account)    */
/* Warning: unofficial Github mirror is not supported by author!  */
/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */

const char *stats_html_signature = "<span class=\"small\">Statistics generated by Prometheus QoS version %s<br />GPL+Copyright(C)2005-2013 Michael Polak, <a target=\"_blank\" href=\"http://www.arachne.cz/\">Arachne Labs</a></span>\n";

#define STRLEN 512
#undef DEBUG

/* ======= All path names are defined here (for RPM patch) =======  */

const char               *tc = "/sbin/tc"; /* requires tc with HTB support */
const char         *iptables = "/sbin/iptables"; /* requires iptables utility */
const char        *ip6tables = "/sbin/ip6tables"; /* requires iptables utility */
const char     *iptablessave = "/sbin/iptables-save"; /* not yet required */
const char  *iptablesrestore = "/sbin/iptables-restore";  /* requires iptables-restore */
const char    *ip6tablessave = "/sbin/ip6tables-save"; /* not yet required */
const char *ip6tablesrestore = "/sbin/ip6tables-restore";  /* requires iptables-restore */
const char               *ls = "/bin/ls"; /* this is not user configurable :-) */

char          *config = "/etc/prometheus/prometheus.conf"; /* main configuration file */
char           *hosts = "/etc/prometheus/hosts"; /* per-IP bandwidth definition file */
char    *iptablesfile = "/var/spool/prometheus.iptables"; /* temporary file for iptables-restore*/
char   *ip6tablesfile = "/var/spool/prometheus.ip6tables"; /* temporary file for ip6tables-restore*/
char          *credit = "/var/lib/misc/prometheus.credit"; /* credit log file */
char        *classmap = "/var/lib/misc/prometheus.classes"; /* credit log file */
char            *html = "/var/www/traffic.html"; /* hall of fame - html version */
char         *preview = "/var/www/preview.html"; /* hall of fame preview - html version */
char    *json_traffic = "/var/www/logs/traffic.json"; /* hall of fame - json version */
char    *json_preview = "/var/www/logs/preview.json"; /* hall of fame preview - json version */
char          *cmdlog = "/var/log/prometheuslog"; /* command log filename */
char         *log_dir = "/var/www/logs/"; /* log directory pathname, ended with slash */
char         *log_url = "/logs/"; /* log directory relative URI prefix (partial URL) */
char    *html_log_dir = "/var/www/logs/html/";

char      *jquery_url = "http://code.jquery.com/jquery-latest.js";
char         *lms_url = "/lms/?m=customerinfo&amp;id=";
int use_jquery_popups = TRUE;
int      row_odd_even = 0; /*<tr class="odd/even"> */
 
/* === Configuraration file values defaults - stored in global variables ==== */

int        filter_type = 1; /*1 mark, 2 classify*/
char      *final_chain = "DROP"; /* REJECT would be better, but it is impossible in mangle */
char             *mark = "MARK";
char    *mark_iptables = "MARK --set-mark ";
int            dry_run = FALSE; /* preview - use puts() instead of system() */
char *iptablespreamble = "*mangle\n:PREROUTING ACCEPT [0:0]\n:POSTROUTING ACCEPT [0:0]\n:INPUT ACCEPT [0:0]\n:OUTPUT ACCEPT [0:0]\n:FORWARD ACCEPT [0:0]";
char      *ip6preamble = "-A FORWARD -p ipv6-icmp -j ACCEPT\n-A POSTROUTING -p ipv6-icmp -j ACCEPT\n-A FORWARD -s fe80::/10 -j ACCEPT\n-A FORWARD -d ff00::/8 -j ACCEPT\n-A POSTROUTING -s fe80::/10 -j ACCEPT\n-A POSTROUTING -d ff00::/8 -j ACCEPT";
FILE    *iptables_file = NULL;
FILE   *ip6tables_file = NULL;
int      enable_credit = TRUE; /* enable credit file */
int         use_credit = FALSE; /* use credit file (if enabled)*/
char            *title = "Hall of Fame - Greatest Suckers"; /* hall of fame title */
int       hall_of_fame = TRUE; /* enable hall of fame */
char              *lan = "eth0"; /* LAN interface */
char       *lan_medium = "100Mbit"; /* 10Mbit/100Mbit ethernet */
char              *wan = "eth1"; /* WAN/ISP interface */
char        *ip6prefix = NULL; /* Prefix for global /48 IPv6 subnet */
char       *wan_medium = "100Mbit"; /* 10Mbit/100Mbit ethernet */
char         *qos_leaf = "sfq perturb 5"; /* leaf discipline */
char    *qos_free_zone = NULL; /* QoS free zone */
int          qos_proxy = TRUE; /* include proxy port to QoS */
int        found_lmsid = FALSE; /* show links to users in LMS information system */
int     include_upload = TRUE; /* upload+download=total traffic */
char         *proxy_ip = "192.168.1.1/32"; /* our IP with proxy port */
int         proxy_port = 3128; /* proxy port number */
long long int     line = 1024; /* WAN/ISP download in kbps */
long long int       up = 1024; /* WAN/ISP upload in kbps */
int           free_min = 256; /* minimum guaranted bandwidth for all undefined hosts */
int           free_max = 512; /* maximum allowed bandwidth for all undefined hosts */
int     qos_free_delay = 0; /* seconds to sleep before applying new QoS rules */
int     digital_divide = 2; /* controls digital divide weirdness ratio, 1...3 */ 
int        max_nesting = 3; /* maximum nesting of HTB clases, built-in maximum seems to be 4 */
int            htb_r2q = 256; /* should work for leaf values 512 kbps to 8 Mbps */
int              burst = 8; /* HTB burst (in kbits) */
int         burst_main = 64;
int        burst_group = 32;
int     magic_treshold = 8; /* reduce ceil by X*magic_treshhold kbps (hard shaping) */
int       keywordcount = 0;
int        class_count = 0;
int           ip_count = 0;
/* not yet implemented:
int      fixed_packets = 0; maximum number of pps per IP address (not class!) 
int       packet_limit = 5; maximum number of pps to htn CEIL, not rate !!! 
*/
FILE         *log_file = NULL;
char              *kwd = "via-prometheus"; /* /etc/hosts comment, eg. #qos-64-128 */

const int highest_priority   = 0; /* highest HTB priority (HTB built-in value is 0) */
const int lowest_priority    = 7; /* lowest HTB priority (HTB built-in value is 7) */
const int idxtable_treshold1 = 24;      /* this is no longer configurable */
const int idxtable_treshold2 = 12;      /* this is no longer configurable */
const int idxtable_bitmask1  = 3;        /* this is no longer configurable */
const int idxtable_bitmask2  = 3;        /* this is no longer configurable */

struct IP *ips = NULL, *ip, *sharedip;
struct Group *groups = NULL, *group;
struct Keyword *keyword, *defaultkeyword=NULL, *keywords=NULL;

void help(void);
/* implemented in help.c */

void get_traffic_statistics(const char *whichiptables, int ipv6);
/* implemented in parseiptables.c */

void parse_ip_log(int argc, char **argv);
/* implemented in parselog.c */

void parse_hosts(char *hosts);
/* implemented in parsehosts.c */

void write_json_traffic(char *json);
/* implemented in json.c */

void write_htmlandlogs(char *html, char *d, int total, int just_preview);
/* implemented in htmlandlogs.c */

const char *tr_odd_even(void)
{
 row_odd_even = 1 - row_odd_even;
 if(row_odd_even)
 {
  return "<tr class=\"even\">\n";
 }
 else
 {
  return "<tr class=\"odd\">\n";
 }
}

/* ==== This is C<<1 stuff - learn C<<1 first! https://dev.arachne.cz/svn/cll1h ==== */
/* (except that this code uses obsolete, archaic version of this header file...)     */

struct Index
{
 char *addr;
 char *id;
 struct Index *parent;
 int bitmask;
 int children;
 int ipv6;
 list(Index);
} *idxs=NULL, *idx, *metaindex;


/* ====== iptables indexes are used to reduce complexity to log8(N) ===== */

char *index_id(char *ip, int bitmask);
/* function implemented in ipv4subnets.c */

char *subnet_id(char *ip, int bitmask);
/* function implemented in ipv4subnets.c */

char *index6_id(char *ip, int bitmask);
/* function implemented in ipv6subnets.c */

char *subnet6_id(char *ip, int bitmask);
/* function implemented in ipv6subnets.c */

/* ================= Let's parse configuration file here ================ */

void reject_config_and_exit(char *filename)
{
 printf("Configuration file %s rejected - abnormal exit.",filename);
 exit(-1);
}

void get_config(char *config_filename)
{
 char *cnf="mark";
 
 printf("Configured keywords: ");
 parse(config_filename)
 {
  option("keyword",kwd);
  if(kwd)
  {
   printf("%s ",kwd);

   create(keyword,Keyword);
   keyword->key=kwd;
   keyword->asymetry_ratio=1;          /* ratio for ADSL-like upload */
   keyword->asymetry_fixed=0;          /* fixed treshold for ADSL-like upload */
   keyword->data_limit=8;              /* hard shaping: apply magic_treshold if max*data_limit MB exceeded */
   keyword->data_prio=4;               /* soft shaping (qos): reduce HTB prio if max*data_prio MB exceeded */
   keyword->fixed_limit=0;             /* fixed data limit for setting lower HTB ceil */
   keyword->fixed_prio=0;              /* fixed data limit for setting lower HTB prio */
   keyword->reserve_min=8;	       /* bonus for nominal HTB rate bandwidth (in kbps) */
   keyword->reserve_max=0;	       /* malus for nominal HTB ceil (in kbps) */
   keyword->default_prio=highest_priority+1;
   keyword->html_color="000000";
   keyword->ip_count=0;
   keyword->leaf_discipline="";

   push(keyword,keywords);
   if(!defaultkeyword)
   {
    defaultkeyword=keyword;
   }
   keywordcount++;
   
   kwd=NULL;
  }
  else
  {
    for_each(keyword,keywords)
    {
     int l=strlen(keyword->key);

     if(!strncmp(keyword->key,_,l) && strlen(_)>l+2)
     {
      char *tmptr=_; /*  <---- l+1 ----> */
      _+=l+1;        /*  via-prometheus-asymetry-ratio, etc. */
      ioption("asymetry-ratio",keyword->asymetry_ratio);
      ioption("asymetry-treshold",keyword->asymetry_fixed);
      ioption("magic-relative-limit",keyword->data_limit);
      ioption("magic-relative-prio",keyword->data_prio);
      loption("magic-fixed-limit",keyword->fixed_limit);
      loption("magic-fixed-prio",keyword->fixed_prio);
      ioption("htb-default-prio",keyword->default_prio);
      ioption("htb-rate-bonus",keyword->reserve_min);
      ioption("htb-ceil-malus",keyword->reserve_max);
      option("leaf-discipline",keyword->leaf_discipline);
      option("html-color",keyword->html_color);
      _=tmptr;
      
      if(keyword->data_limit || keyword->fixed_limit || 
         keyword->data_prio || keyword->fixed_prio)
      {
       use_credit=1;        
      }
     }
    }
  }

  option("tc",tc);
  option("iptables",iptables);
  option("iptables-save",iptablessave);
  option("iptables-restore",iptablesrestore);
  option("ip6tables",ip6tables);
  option("ip6tables-save",ip6tablessave);
  option("ip6tables-restore",ip6tablesrestore);
  option("iptables-in-filename",iptablesfile);
  option("ip6tables-in-filename",ip6tablesfile);
  option("hosts",hosts);
  option("lan-interface",lan);
  option("wan-interface",wan);
  option("ip6-prefix",ip6prefix);
  option("lan-medium",lan_medium);
  option("wan-medium",wan_medium);
  lloption("wan-download",line);
  lloption("wan-upload",up);
  ioption("hall-of-fame-enable",hall_of_fame);
  option("hall-of-fame-title",title);
  option("hall-of-fame-filename",html);
  option("json-filename",json_traffic);
  option("hall-of-fame-preview",preview);
  option("json-preview",json_preview);
  option("log-filename",cmdlog);
  option("credit-filename",credit);
  option("classmap-filename",classmap);
  ioption("credit-enable",enable_credit);
  option("log-traffic-directory",log_dir);
  option("log-traffic-html-directory",html_log_dir);
  option("log-traffic-url-path",log_url);
  option("jquery-url",jquery_url);
  option("lms-url",lms_url);
  ioption("use-jquery-popups",use_jquery_popups);
  option("qos-free-zone",qos_free_zone);
  ioption("qos-free-delay",qos_free_delay);
  ioption("qos-proxy-enable",qos_proxy);
  option("qos-proxy-ip",proxy_ip);
  option("htb-leaf-discipline",qos_leaf);
  ioption("qos-proxy-port",proxy_port);
  ioption("free-rate",free_min);
  ioption("free-ceil",free_max);
  ioption("htb-burst",burst);
  ioption("htb-burst-main",burst_main);
  ioption("htb-burst-group",burst_group);
  ioption("htb-nesting-limit",max_nesting);
  ioption("htb-r2q",htb_r2q);
  ioption("magic-include-upload",include_upload);
  ioption("magic-treshold",magic_treshold);  
  option("filter-type", cnf);  
/* not yet implemented:
  ioption("magic-fixed-packets",fixed_packets);
  ioption("magic-relative-packets",packet_limit);
*/
 }
 fail
 { 
  perror(config_filename);
  puts("Warning - using built-in defaults instead ...");
 }
 done; /* ugly macro end */
 printf("\n");
 
 /* leaf discipline for keywords */
 for_each(keyword,keywords)
 {
    if(!strcmpi(keyword->leaf_discipline, ""))
    {
        keyword->leaf_discipline = qos_leaf;
    }
 }

 if(strcmpi(cnf, "mark"))
 {
  filter_type = 2;
  mark = "CLASSIFY";
  mark_iptables = "CLASSIFY --set-class 1:";
 }
 else
 {
  filter_type = 1;
  mark = "MARK";
  mark_iptables = "MARK --set-mark ";
 }

 /* are supplied values meaningful ?*/
 if(line<=0 || up<=0)
 {
  puts("Illegal value of LAN or WAN bandwidth: 0 kbps.");
  reject_config_and_exit(config_filename);
 }
}

 
/* ========== This function executes, logs OR ALSO prints command ========== */

void safe_run(char *cmd)
{
 if(dry_run)
 {
  printf("\n=>%s\n",cmd);
 }
 else
 {
  system(cmd);
 }
 if(log_file)
 {
  fprintf(log_file,"%s\n",cmd);
 }
}

void iptables_save_line(char *line, int ipv6)
{
 if(ipv6)
 {
  fprintf(ip6tables_file,"%s\n",line);
 }
 else
 {
  fprintf(iptables_file,"%s\n",line);
 }
}

void run_iptables_restore(void)
{
 char *restor;
 string(restor,STRLEN);

 /*-----------------------------------------------------------------*/
 printf("Running %s <%s ...\n", iptablesrestore, iptablesfile);
 /*-----------------------------------------------------------------*/

 iptables_save_line("COMMIT", FALSE);
 fclose(iptables_file);
 if(dry_run) 
 {
  parse(iptablesfile)
  {
   printf("%s\n",_);
  }
  done; /* ugly macro end */
 }

 sprintf(restor,"%s <%s",iptablesrestore, iptablesfile);
 safe_run(restor);

 if(ip6prefix)
 {
  /*-----------------------------------------------------------------*/
  printf("Running %s <%s ...\n", ip6tablesrestore, ip6tablesfile);
  /*-----------------------------------------------------------------*/
  iptables_save_line("COMMIT", TRUE);
  fclose(ip6tables_file);
  if(dry_run) 
  {
   parse(ip6tablesfile)
   {
    printf("%s\n",_);
   }
   done; /* ugly macro end */
  }
  sprintf(restor,"%s <%s",ip6tablesrestore, ip6tablesfile);
  safe_run(restor);
 }
 free(restor);
}

char *parse_datafile_line(char *str)
{
 char *ptr=strchr(str,' ');

 if(ptr)
 {
  *ptr=0;
  ptr++;
  return ptr;
 } 
 else 
 {
  return NULL;
 }
}


/*-----------------------------------------------------------------*/
/* Are you looking for int main(int argc, char **argv) ? :-))      */
/*-----------------------------------------------------------------*/

program
{
 int i=0;                    /* just plain old Fortran style integer :-) */
 FILE *f=NULL;               /* everything is just stream of bytes... */
 char *str, *ptr, *d;        /* LET A$=B$ :-) */
 char *substring;

 int parent        = 1;
 int just_flush    = FALSE;       /* deactivates all previous actions */
 int nodelay       = FALSE;
 int just_preview  = FALSE;       /* preview - generate just stats */
 int start_shaping = FALSE;       /* apply FUP - requires classmap file */
 int just_logs     = FALSE;       /* just parse logs */
 int run           = FALSE;
 int total         = 0;
 
 char *chain_forward, *chain_postrouting;
 char *althosts=NULL;
  
 printf("\n\
Prometheus QoS - \"fair-per-IP\" Quality of Service setup utility.\n\
Version %s - Copyright (C)2005-2013 Michael Polak, Arachne Labs\n\
iptables-restore & burst tunning & classify modification by Ludva\n\
Credit: CZFree.Net, Martin Devera, Netdave, Aquarius, Gandalf\n\n",version);

 /*----- Boring... we have to check command line options first: ----*/   
 arguments
 {
  argument("-c") { nextargument(config); }
  argument("-h") { nextargument(althosts);}
  argument("-d") { run=TRUE; dry_run=TRUE; }
  argument("-f") { run=TRUE; just_flush=TRUE; }
  argument("-9") { run=TRUE; just_flush=9; }
  argument("-p") { run=TRUE; just_preview=TRUE; }
  argument("-s") { run=TRUE; just_preview=TRUE; start_shaping=TRUE; }
  argument("-r") { run=TRUE; }
  argument("-n") { run=TRUE; nodelay=TRUE; }
  argument("-l") { just_logs=TRUE; }
  argument("-m") { just_logs=TRUE; }
  argument("-y") { just_logs=TRUE; }
  argument("-?") { help(); exit(0); }
  argument("--help") { help(); exit(0); }
  argument("-v") { exit(0); } 
  argument("--version") { exit(0); } 
 }
 
 if(dry_run)
 {
  puts("*** THIS IS JUST DRY RUN ! ***\n");
 }

 date(d); /* this is typical cll1.h macro - prints current date */

 /*-----------------------------------------------------------------*/
 printf("Parsing configuration file %s ...\n", config);
 /*-----------------------------------------------------------------*/
 get_config(config);
 
 if(just_logs)
 {
  parse_ip_log(argc,argv);
  exit(0);
 }
 else if(not run)
 {
  help();
  exit(0);
 }

 if(althosts)
 {
  hosts=althosts;
 }

 if(just_flush<9)
 {
  /*-----------------------------------------------------------------*/
  puts("Parsing iptables verbose output ...");
  /*-----------------------------------------------------------------*/
  get_traffic_statistics(iptables, FALSE);
  if(ip6prefix)
  {
   /*-----------------------------------------------------------------*/
   puts("Parsing ip6tables verbose output ...");
   /*-----------------------------------------------------------------*/  
   get_traffic_statistics(ip6tables, TRUE);
  }
 }

 /*-----------------------------------------------------------------*/
 printf("Parsing class defintion file %s ...\n", hosts);
 /*-----------------------------------------------------------------*/
 parse_hosts(hosts);

 /*-----------------------------------------------------------------*/
 /* cll1.h - let's allocate brand new character buffer...           */
 /*-----------------------------------------------------------------*/
 string(str,STRLEN); 

 /*-----------------------------------------------------------------*/
 puts("Resolving shared connections ...");
 /*-----------------------------------------------------------------*/
 for_each(ip,ips) if(ip->sharing)
 {
  for_each(sharedip,ips) if(eq(sharedip->name, ip->sharing))
  {
   sharedip->traffic += ip->traffic;
   ip->traffic = 0;
   ip->mark = sharedip->mark; 
   ip->lmsid = sharedip->lmsid;
   break;
  }
  if(not sharedip)
  {
   printf("Unresolved shared connection: %s %s sharing-%s\n",
          ip->addr, ip->name, ip->sharing);
  }
 }

 if(enable_credit && just_flush<9)
 {
  /*-----------------------------------------------------------------*/
  printf("Parsing credit file %s ...\n", credit);
  /*-----------------------------------------------------------------*/
  parse(credit)
  {
   ptr=parse_datafile_line(_);
   if(ptr)
   {
    if_exists(ip,ips,eq(ip->addr,_))
    {
     sscanf(ptr,"%Lu",&(ip->credit));
    }
   }
  }
  done; /* ugly macro end */
 }

 if(!just_preview)
 {
  /*-----------------------------------------------------------------*/
  puts("Initializing iptables and tc classes ...");
  /*-----------------------------------------------------------------*/
  
  iptables_file = fopen(iptablesfile, "w");
  if(iptables_file == NULL)
  {
    perror(iptablesfile);
    exit(-1);
  }
  iptables_save_line(iptablespreamble, FALSE);

  if(ip6prefix)
  {
   ip6tables_file = fopen(ip6tablesfile, "w");
   if(ip6tables_file == NULL)
   {
     perror(ip6tablesfile);
     exit(-1);
   }
   iptables_save_line(iptablespreamble, TRUE);
   iptables_save_line(ip6preamble, TRUE);
  }

  run_iptables_restore();
  
  log_file = fopen(cmdlog, "w");
  if(log_file == NULL) 
  {
    perror(cmdlog);
    exit(-1);
  }  
  
  sprintf(str,"%s qdisc del dev %s root 2>/dev/null",tc,lan);
  safe_run(str);

  sprintf(str,"%s qdisc del dev %s root 2>/dev/null",tc,wan);
  safe_run(str);
  
  iptables_file=fopen(iptablesfile,"w");
  iptables_save_line(iptablespreamble, FALSE);
  if(ip6prefix)
  {
   ip6tables_file=fopen(ip6tablesfile,"w");
   iptables_save_line(iptablespreamble, TRUE);
   iptables_save_line(ip6preamble, TRUE);
  }

  if(qos_free_zone && *qos_free_zone!='0') /* this is currently supported only for IPv4 */
  {
   char *chain;
   
   sprintf(str,"-A FORWARD -d %s -o %s -j ACCEPT", qos_free_zone, wan);
   iptables_save_line(str, FALSE); /* this is currently supported only for IPv4 */
   
   if(qos_proxy)
   {
    iptables_save_line(":post_noproxy - [0:0]", FALSE);
    sprintf(str,"-A POSTROUTING ! -p tcp -o %s -j post_noproxy", lan);
    iptables_save_line(str , FALSE);
    sprintf(str,"-A POSTROUTING ! -s %s -o %s -j post_noproxy", proxy_ip, lan);
    iptables_save_line(str, FALSE);
    sprintf(str,"-A POSTROUTING -s %s -p tcp ! --sport %d -o %s -j post_noproxy", proxy_ip, proxy_port, lan);
    iptables_save_line(str, FALSE);

    chain="post_noproxy";    
   }
   else
   {
    chain="POSTROUTING";
   }
    
   sprintf(str,"-A %s -s %s -o %s -j ACCEPT", chain, qos_free_zone, lan);
   iptables_save_line(str, FALSE);
  }
  
  if(ip_count > idxtable_treshold1 && !just_flush)
  {
   int idxcount=0, bitmask=32-idxtable_bitmask1;
   char *subnet, *buf;
   /*-----------------------------------------------------------------*/
   printf("Detected %d addresses - indexing iptables rules to improve performance...\n",ip_count);
   /*-----------------------------------------------------------------*/

   iptables_save_line(":post_common - [0:0]", FALSE);
   iptables_save_line(":forw_common - [0:0]", FALSE);
   if(ip6prefix)
   {
    iptables_save_line(":post_common - [0:0]", TRUE);
    iptables_save_line(":forw_common - [0:0]", TRUE);
   }

   for_each(ip,ips) if(ip->addr && *(ip->addr) && !eq(ip->addr,"0.0.0.0/0")) 
   {
    if(ip->v6)
    {
     buf=index6_id(ip->addr,bitmask+32);
    }
    else
    {
     buf=index_id(ip->addr, bitmask);
    }
    
    if_exists(idx,idxs,eq(idx->id,buf))
    {
     idx->children++;
    }
    else
    {
     create(idx,Index);
     idx->addr = ip->addr;
     idx->id = buf;
     idx->bitmask = bitmask+32*ip->v6;
     idx->parent = NULL;
     idx->children = 0;
     idx->ipv6 = ip->v6;
     idxcount++;
     push(idx,idxs);
    }
   }

   /* brutal perfomance optimalization */
   while(idxcount > idxtable_treshold2 && bitmask > 2*idxtable_bitmask2)
   {
    bitmask -= idxtable_bitmask2;
    idxcount = 0;

    for_each(idx,idxs) if(idx->parent == NULL)
    {
     if(idx->ipv6)
     {
      buf = index6_id(idx->addr, bitmask+32);
     }
     else
     {
      buf = index_id(idx->addr, bitmask);
     }
     if_exists(metaindex,idxs,eq(metaindex->id,buf))
     {
      metaindex->children++;
     }
     else
     {
      create(metaindex,Index);
      metaindex->addr = idx->addr;
      metaindex->id = buf;
      metaindex->bitmask = bitmask+32*idx->ipv6;
      metaindex->parent = NULL;
      metaindex->children = 0;
      metaindex->ipv6 = idx->ipv6;
      idxcount++;
      push(metaindex,idxs);
     }
     idx->parent=metaindex;
    }
   }

   /* this should slightly optimize throughput ... */
   sort(idx,idxs,desc_order_by,children);
   sort(idx,idxs,order_by,bitmask);

   i=0;
   for_each(idx,idxs)
   {
    if(idx->ipv6)
    {
     subnet=subnet6_id(idx->addr, idx->bitmask);
    }
    else
    {
     subnet=subnet_id(idx->addr, idx->bitmask);
    }
    printf("%d: %s/%d\n", ++i, subnet, idx->bitmask);
       
    sprintf(str,":post_%s - [0:0]", idx->id);
    iptables_save_line(str, idx->ipv6);

    sprintf(str,":forw_%s - [0:0]", idx->id);
    iptables_save_line(str, idx->ipv6);

    if(idx->parent)
    {
     string(buf,strlen(idx->parent->id)+6);
     sprintf(buf,"post_%s", idx->parent->id);
    }
    else
    {
     buf="POSTROUTING";
    }

    sprintf(str,"-A %s -d %s/%d -o %s -j post_%s", buf, subnet, idx->bitmask, lan, idx->id);
    iptables_save_line(str, idx->ipv6);

    sprintf(str,"-A %s -d %s/%d -o %s -j post_common", buf, subnet, idx->bitmask, lan);
    iptables_save_line(str, idx->ipv6);

    if(idx->parent)
    {
     string(buf,strlen(idx->parent->id)+6);
     sprintf(buf,"forw_%s",idx->parent->id);
    }
    else
    {
     buf="FORWARD";
    }

    sprintf(str,"-A %s -s %s/%d -o %s -j forw_%s", buf, subnet, idx->bitmask, wan, idx->id);
    iptables_save_line(str, idx->ipv6);

    sprintf(str,"-A %s -s %s/%d -o %s -j forw_common", buf, subnet, idx->bitmask, wan);
    iptables_save_line(str, idx->ipv6);
   }
   printf("Total indexed iptables chains created: %d\n", i);

   sprintf(str,"-A FORWARD -o %s -j forw_common", wan);
   iptables_save_line(str, FALSE);
   
   sprintf(str,"-A POSTROUTING -o %s -j post_common", lan);
   iptables_save_line(str, FALSE);

   if(ip6prefix)
   {
    sprintf(str,"-A FORWARD -o %s -j forw_common", wan);
    iptables_save_line(str, TRUE);
    
    sprintf(str,"-A POSTROUTING -o %s -j post_common", lan);
    iptables_save_line(str, TRUE);
   }
  }
 }

 if(just_flush)
 {
  fclose(iptables_file);
  if(log_file)
  { 
   fclose(log_file);
  }
  puts("Just flushed iptables and tc classes - now exiting ...");
  exit(0);
 }

 if(!just_preview)
 {
  if(!dry_run && !nodelay && qos_free_delay)
  {
   printf("Flushed iptables and tc classes - now sleeping for %d seconds...\n",qos_free_delay);
   sleep(qos_free_delay);
  }

  sprintf(str,"%s qdisc add dev %s root handle 1: htb r2q %d default 1",
              tc,lan,htb_r2q);
  safe_run(str);

  sprintf(str, "%s class add dev %s parent 1: classid 1:2 htb rate %s ceil %s burst %dk prio %d",
               tc,lan,lan_medium,lan_medium,burst_main,highest_priority);
  safe_run(str);

  sprintf(str, "%s class add dev %s parent 1:2 classid 1:1 htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d",
                tc,lan,line,line,burst_main,highest_priority);
  safe_run(str);

  sprintf(str,"%s qdisc add dev %s root handle 1: htb r2q %d default 1",tc,wan,htb_r2q);
  safe_run(str);

  sprintf(str, "%s class add dev %s parent 1: classid 1:2 htb rate %s ceil %s burst %dk prio %d",
               tc,wan,wan_medium,wan_medium,burst_main,highest_priority);
  safe_run(str);

  sprintf(str, "%s class add dev %s parent 1:2 classid 1:1 htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d",
               tc,wan,up,up,burst_main,highest_priority);
  safe_run(str);
 }

 /*-----------------------------------------------------------------*/
 puts("Locating heavy downloaders and generating root classes ...");
 /*-----------------------------------------------------------------*/
 sort(ip,ips,desc_order_by,traffic); 

 /*-----------------------------------------------------------------*/
 /* sub-scope - local variables */  
 {
  long long int rate = line;
  long long int max = line;
  int group_count = 0;
  FILE *credit_file = NULL;
  
  if(!just_preview && !dry_run && enable_credit)
  {
   credit_file = fopen(credit,"w");
  }
    
  for_each(group,groups)
  {
   if(!just_preview)
   {
    //download
    sprintf(str,"%s class add dev %s parent 1:%d classid 1:%d htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d #down desired %d", 
                 tc, lan, parent, group->id, rate, max, burst_group, highest_priority+1, group->desired);
    safe_run(str);
    
    //upload
    sprintf(str,"%s class add dev %s parent 1:%d classid 1:%d htb rate %Ldkbit ceil %Ldkbit burst %dk prio %d #up desired %d", 
                 tc, wan, parent, group->id, rate*up/line, max*up/line, burst_group, highest_priority+1, group->desired);
    safe_run(str);
   }
   
   if(group_count++ < max_nesting)
   {
    parent = group->id;
   }
   
   rate -= digital_divide*group->min;
   if(rate < group->min)
   {
    rate = group->min;
   }
    
   /*shaping of aggresive downloaders, with credit file support */
   if(use_credit)
   {
    int group_rate = group->min, priority_sequence = lowest_priority;
    
    for_each(ip, ips) if(ip->min == group->min && ip->max > ip->min)
    {
     ip->realquota=ip->credit+(ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20));
     if(     ip->keyword->data_limit 
         and not ip->fixedprio 
         and ip->traffic > ip->realquota )
     {
      if(group_rate < ip->max)
      {
       ip->max = group_rate;
      }
      group_rate+=magic_treshold;
      ip->prio=lowest_priority;
      if(ip->prio<highest_priority+2)
      {
       ip->prio=highest_priority+2;
      }
     }
     else
     {
      if(    ip->keyword->data_prio 
          && !ip->fixedprio 
          && (   ip->traffic>ip->credit
               + (ip->min*ip->keyword->data_prio+(ip->keyword->fixed_prio<<20))) )
      {
       ip->prio=priority_sequence--;
       if(ip->prio<highest_priority+1)
       {
        ip->prio=highest_priority+1;
       }
      }
     
      if(credit_file)
      {
       unsigned long long lcredit=0;
       
       if((ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20))>ip->traffic)
       {
        lcredit=(ip->min*ip->keyword->data_limit+(ip->keyword->fixed_limit<<20))-ip->traffic;
       }
       fprintf(credit_file,"%s %Lu\n",ip->addr,lcredit);
      }
     }
    }        
   }
  }
  if(credit_file)
  {
   fclose(credit_file);
  }
 }

 if(just_preview)
 {
  if(start_shaping)
  {
   printf("Reading %s and applying Fair Use Policy rules ... \n", classmap);
   parse(classmap)
   {
    ptr=strchr(_,' ');
    if(ptr)
    {
     *ptr=0;
     ptr++;
     if_exists(ip,ips,eq(ip->addr,_))
     {
      ip->mark=atoi(ptr);
      if(ip->max < ip->desired) /* apply FUP limit immediately.... */
      {
       printf("Applying limit for %-22s %-16s %04d ", ip->name, ip->addr, ip->mark);       
       printf("(down: %dk-%dk ", ip->min, ip->max); 
       sprintf(str, "%s class change dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d", 
                    tc, lan, ip->group, ip->mark,ip->min,ip->max, burst, ip->prio);
       safe_run(str);
       printf("up: %dk-%dk)\n", (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), 
                                (int)((ip->max/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed));
       sprintf(str,"%s class change dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d",
                    tc, wan, ip->group, ip->mark,
                    (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed),
                    (int)((ip->max/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), burst, ip->prio);
       safe_run(str);
      }
     }
    }
   }
   fail
   { 
    perror(classmap);
    puts("Warning - classmap file not fund, just generating preview ...");
    start_shaping=FALSE;
   }
   done; /* ugly macro end */
  }
  html=preview;
  json_traffic=json_preview;
 }

 if(!dry_run && !just_flush)
 {
  /*-----------------------------------------------------------------*/
  printf("Writing json traffic overview  %s ... ", json_traffic);
  /*-----------------------------------------------------------------*/
  write_json_traffic(json_traffic);

  /*-----------------------------------------------------------------*/
  printf("Writing statistics into HTML page %s ...\n", html);
  /*-----------------------------------------------------------------*/
  write_htmlandlogs(html, d, total, just_preview);
 }

 if(just_preview)
 {
  char swchar='p';
  if(start_shaping)
  {
   swchar='s';
  }
  printf("Statistics preview generated (-%c switch) - now exiting ...\n", swchar);
  exit(0);
 }  

 i=0;
#ifdef DEBUG
 printf("%-22s %-15s mark\n","name","ip");
#endif

 printf("Writing %s", classmap); 
 f = fopen(classmap, "w"); 
 if(f < 0)
 {
  perror(classmap);
 }

 /*-----------------------------------------------------------------*/
 printf(" + generating iptables and tc classes ... ");
 /*-----------------------------------------------------------------*/

 for_each(ip, ips) if(ip->mark > 0) /* works only for IPv4 so far */
 {
  if(idxs)
  {
   char *buf;
   duplicate(ip->addr,buf);
   if(ip->v6)
   {
    buf=index6_id(ip->addr,64-idxtable_bitmask1);
   }
   else
   {
    buf=index_id(ip->addr,32-idxtable_bitmask1);
   }
   
   string(chain_forward,6+strlen(buf));
   strcpy(chain_forward,"forw_");
   strcat(chain_forward,buf);

   string(chain_postrouting,6+strlen(buf));
   strcpy(chain_postrouting,"post_");
   strcat(chain_postrouting,buf);
   
   free(buf);
  }
  else
  {
   chain_forward="FORWARD";
   chain_postrouting="POSTROUTING";
  }

#ifdef DEBUG
  printf("%-22s %-16s %04d ", ip->name, ip->addr, ip->mark); 
#endif

  /* -------------------------------------------------------- mark download */
  
  sprintf(str, "-A %s -d %s/%d -o %s -j %s%d",
               chain_postrouting, ip->addr, 32*(1+ip->v6), lan, mark_iptables, ip->mark);
  /* -m limit --limit 1/s */  
  iptables_save_line(str, ip->v6);

  if(qos_proxy)
  {
   sprintf(str, "-A %s -s %s -p tcp --sport %d -d %s/%d -o %s -j %s%d",
                chain_postrouting, proxy_ip, proxy_port, ip->addr, 32*(1+ip->v6), lan, mark_iptables, ip->mark);
   iptables_save_line(str, ip->v6);
  }

  sprintf(str, "-A %s -d %s/%d -o %s -j ACCEPT",
               chain_postrouting, ip->addr, 32*(1+ip->v6), lan);
  iptables_save_line(str, ip->v6);

  /* -------------------------------------------------------- mark upload */
  sprintf(str, "-A %s -s %s/%d -o %s -j %s%d", 
               chain_forward, ip->addr, 32*(1+ip->v6), wan, mark_iptables, ip->mark);
  iptables_save_line(str, ip->v6);

  sprintf(str, "-A %s -s %s/%d -o %s -j ACCEPT",
               chain_forward, ip->addr, 32*(1+ip->v6), wan);
  iptables_save_line(str, ip->v6);

  if(ip->min)
  {
   /* -------------------------------------------------------- download class */
#ifdef DEBUG
   printf("(down: %dk-%dk ", ip->min, ip->max); 
#endif

   sprintf(str, "%s class add dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d", 
                tc, lan, ip->group, ip->mark,ip->min,ip->max, burst, ip->prio);
   safe_run(str);

   if(strcmpi(ip->keyword->leaf_discipline, "none"))
   {
    sprintf(str, "%s qdisc add dev %s parent 1:%d handle %d %s", 
                 tc, lan, ip->mark, ip->mark, ip->keyword->leaf_discipline); /*qos_leaf*/
    safe_run(str);
   }

   if(filter_type == 1)
   {
    sprintf(str, "%s filter add dev %s parent 1:0 protocol ip handle %d fw flowid 1:%d",
                 tc, lan, ip->mark, ip->mark);
    safe_run(str);
   }

   /* -------------------------------------------------------- upload class */
#ifdef DEBUG
   printf("up: %dk-%dk)\n", (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), 
                            (int)((ip->max/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed));
#endif

   sprintf(str,"%s class add dev %s parent 1:%d classid 1:%d htb rate %dkbit ceil %dkbit burst %dk prio %d",
                tc, wan, ip->group, ip->mark,
                (int)((ip->min/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed),
                (int)((ip->max/ip->keyword->asymetry_ratio)-ip->keyword->asymetry_fixed), burst, ip->prio);
   safe_run(str);
   
   if(strcmpi(ip->keyword->leaf_discipline, "none"))
   {
    sprintf(str, "%s qdisc add dev %s parent 1:%d handle %d %s",
                 tc, wan, ip->mark, ip->mark, ip->keyword->leaf_discipline); /*qos_leaf*/
    safe_run(str);
   }   

   if(filter_type == 1)
   {
    sprintf(str, "%s filter add dev %s parent 1:0 protocol ip handle %d fw flowid 1:%d",
                 tc, wan, ip->mark, ip->mark);
    safe_run(str);
   }
  
   if(f > 0)
   {
    fprintf(f, "%s %d\n", ip->addr, ip->mark);
   }
  }
  else
  {
#ifdef DEBUG
   printf("(sharing %s)\n", ip->sharing);
#endif
  }
  i++;
 }
 if(f > 0)
 {
  puts("done.");
  fclose(f);
 }
 
 if(idxs)
 {
  chain_forward = "forw_common";
  chain_postrouting = "post_common";
 }
 else
 {
  chain_forward = "FORWARD";
  chain_postrouting = "POSTROUTING";
 }

 if(free_min)
 {
  final_chain = "ACCEPT";
 }

 if(qos_proxy)
 {
  if(free_min) 
  {
   sprintf(str, "-A %s -s %s -p tcp --sport %d -o %s -j %s%d",
                chain_postrouting,proxy_ip,proxy_port,lan,mark_iptables, 3);
   iptables_save_line(str, FALSE); /* only for IPv4 */
  }
  sprintf(str, "-A %s -s %s -p tcp --sport %d -o %s -j %s",
               chain_postrouting,proxy_ip,proxy_port,lan,final_chain);
  iptables_save_line(str, FALSE); /* only for IPv4 */
 }

 if(free_min)
 {
  sprintf(str, "-A %s -o %s -j %s%d",
               chain_postrouting, lan, mark_iptables, 3);
  iptables_save_line(str, FALSE); /* only for IPv4 */
 }

 sprintf(str,"-A %s -o %s -j %s", chain_postrouting, lan, final_chain);
 iptables_save_line(str, FALSE);
 if(ip6prefix)
 {
  sprintf(str,"-A %s -o %s -j %s", chain_postrouting, lan, final_chain);
  iptables_save_line(str, TRUE);
 }

 if(free_min)
 {
  sprintf(str,"-A %s -o %s -j %s%d", chain_forward, wan, mark_iptables, 3);
  iptables_save_line(str, FALSE); /* only for IPv4 */
 }

 sprintf(str,"-A %s -o %s -j %s", chain_forward, wan, final_chain);
 iptables_save_line(str, FALSE);
 if(ip6prefix)
 {
  sprintf(str,"-A %s -o %s -j %s", chain_postrouting, lan, final_chain);
  iptables_save_line(str, TRUE);
 }

 if(free_min) /* allocate free bandwith if it is not zero... */ 
 {
   /*-----------------------------------------------------------------*/
   puts("Generating free bandwith classes ...");
   /*-----------------------------------------------------------------*/
   sprintf(str, "%s class add dev %s parent 1:%d classid 1:3 htb rate %dkbit ceil %dkbit burst %dk prio %d",
                tc, lan, parent, free_min, free_max,burst, lowest_priority);
   safe_run(str);
   sprintf(str, "%s class add dev %s parent 1:%d classid 1:3 htb rate %dkbit ceil %dkbit burst %dk prio %d",
                tc, wan, parent, free_min, free_max, burst, lowest_priority);
   safe_run(str);
   /* tc SFQ */
   if(strcmpi(qos_leaf, "none"))
   {
     sprintf(str,"%s qdisc add dev %s parent 1:3 handle 3 %s", tc, lan, qos_leaf);
     safe_run(str);
   
     sprintf(str,"%s qdisc add dev %s parent 1:3 handle 3 %s", tc, wan, qos_leaf);
     safe_run(str);
   }   
   /* tc handle 1 fw flowid */
   sprintf(str,"%s filter add dev %s parent 1:0 protocol ip handle 3 fw flowid 1:3", tc, lan);
   safe_run(str);

   sprintf(str,"%s filter add dev %s parent 1:0 protocol ip handle 3 fw flowid 1:3", tc, wan);
   safe_run(str);
 }
 printf("Total IP count: %d\n", i);
 run_iptables_restore();
 if(log_file)
 {
  fclose(log_file);
 }
 return 0;
 /* that's all folks, thank you for reading it all the way up to this point ;-) */
 /* bad luck C<<1 is not yet finished, I promise no sprintf() next time... */
}
